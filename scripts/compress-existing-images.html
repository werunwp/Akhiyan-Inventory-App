<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Compress Existing Images</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 50px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1 {
      color: #333;
      margin-bottom: 20px;
    }
    .config-section {
      margin-bottom: 30px;
      padding: 20px;
      background: #f9f9f9;
      border-radius: 5px;
    }
    .config-section input {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
    }
    button {
      background: #4CAF50;
      color: white;
      padding: 12px 24px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      margin: 5px;
    }
    button:hover {
      background: #45a049;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .stop-btn {
      background: #f44336;
    }
    .stop-btn:hover {
      background: #da190b;
    }
    .log-container {
      margin-top: 20px;
      padding: 15px;
      background: #1e1e1e;
      color: #d4d4d4;
      border-radius: 4px;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 13px;
    }
    .log-entry {
      margin: 5px 0;
      padding: 3px 0;
    }
    .log-success { color: #4CAF50; }
    .log-error { color: #f44336; }
    .log-warning { color: #ff9800; }
    .log-info { color: #2196F3; }
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }
    .stat-card {
      background: #f9f9f9;
      padding: 15px;
      border-radius: 5px;
      text-align: center;
    }
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #4CAF50;
    }
    .stat-label {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
    .progress-bar {
      width: 100%;
      height: 20px;
      background: #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
      margin: 20px 0;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #45a049);
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 12px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üóúÔ∏è Compress Existing Images to Under 50KB</h1>
    
    <div class="config-section">
      <h3>Supabase Configuration</h3>
      <input type="text" id="supabaseUrl" placeholder="Supabase URL (e.g., https://supabase.akhiyanbd.com)" value="https://supabase.akhiyanbd.com">
      <input type="password" id="supabaseKey" placeholder="Supabase Anon Key">
      <input type="text" id="bucketName" placeholder="Bucket Name" value="product-images">
    </div>

    <div>
      <button id="startBtn" onclick="startCompression()">üöÄ Start Compression</button>
      <button id="stopBtn" class="stop-btn" onclick="stopCompression()" disabled>‚èπÔ∏è Stop</button>
    </div>

    <div class="progress-bar" id="progressBar" style="display: none;">
      <div class="progress-fill" id="progressFill">0%</div>
    </div>

    <div class="stats" id="stats" style="display: none;">
      <div class="stat-card">
        <div class="stat-value" id="totalFiles">0</div>
        <div class="stat-label">Total Files</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="processed">0</div>
        <div class="stat-label">Processed</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="compressed">0</div>
        <div class="stat-label">Compressed</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="skipped">0</div>
        <div class="stat-label">Skipped</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="errors">0</div>
        <div class="stat-label">Errors</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="savedSpace">0 MB</div>
        <div class="stat-label">Space Saved</div>
      </div>
    </div>

    <div class="log-container" id="logContainer"></div>
  </div>

  <script>
    let supabase = null;
    let shouldStop = false;
    let stats = {
      total: 0,
      processed: 0,
      compressed: 0,
      skipped: 0,
      errors: 0,
      originalSize: 0,
      compressedSize: 0
    };

    function log(message, type = 'info') {
      const logContainer = document.getElementById('logContainer');
      const entry = document.createElement('div');
      entry.className = `log-entry log-${type}`;
      const timestamp = new Date().toLocaleTimeString();
      entry.textContent = `[${timestamp}] ${message}`;
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    function updateStats() {
      document.getElementById('totalFiles').textContent = stats.total;
      document.getElementById('processed').textContent = stats.processed;
      document.getElementById('compressed').textContent = stats.compressed;
      document.getElementById('skipped').textContent = stats.skipped;
      document.getElementById('errors').textContent = stats.errors;
      
      const savedMB = ((stats.originalSize - stats.compressedSize) / (1024 * 1024)).toFixed(2);
      document.getElementById('savedSpace').textContent = `${savedMB} MB`;
      
      const progress = stats.total > 0 ? (stats.processed / stats.total * 100).toFixed(1) : 0;
      const progressFill = document.getElementById('progressFill');
      progressFill.style.width = progress + '%';
      progressFill.textContent = progress + '%';
    }

    async function compressImage(file, maxWidth = 600, maxHeight = 600, quality = 0.6, maxFileSizeKB = 50) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = (e) => {
          const img = new Image();
          img.src = e.target.result;

          img.onload = () => {
            const canvas = document.createElement('canvas');
            let width = img.width;
            let height = img.height;

            // Calculate new dimensions while maintaining aspect ratio
            if (width > height) {
              if (width > maxWidth) {
                height *= maxWidth / width;
                width = maxWidth;
              }
            } else {
              if (height > maxHeight) {
                width *= maxHeight / height;
                height = maxHeight;
              }
            }

            canvas.width = width;
            canvas.height = height;

            const ctx = canvas.getContext('2d');
            if (!ctx) {
              return reject(new Error('Could not get canvas context'));
            }

            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0, width, height);

            // Function to compress with iterative quality reduction
            const compressWithQuality = (currentQuality) => {
              canvas.toBlob(
                (blob) => {
                  if (!blob) {
                    reject(new Error('Failed to compress image'));
                    return;
                  }
                  
                  const fileSizeKB = blob.size / 1024;
                  
                  // If file size is under maxFileSizeKB or quality is already very low, use this blob
                  if (fileSizeKB <= maxFileSizeKB || currentQuality <= 0.3) {
                    resolve(blob);
                  } else {
                    // Reduce quality and try again
                    const newQuality = Math.max(0.3, currentQuality - 0.05);
                    compressWithQuality(newQuality);
                  }
                },
                'image/jpeg',
                currentQuality
              );
            };

            // Start compression with initial quality
            compressWithQuality(quality);
          };

          img.onerror = () => {
            reject(new Error('Failed to load image'));
          };
        };

        reader.onerror = () => {
          reject(new Error('Failed to read file'));
        };

        reader.readAsDataURL(file);
      });
    }

    async function startCompression() {
      const url = document.getElementById('supabaseUrl').value.trim();
      const key = document.getElementById('supabaseKey').value.trim();
      const bucket = document.getElementById('bucketName').value.trim();

      if (!url || !key || !bucket) {
        alert('Please fill in all configuration fields');
        return;
      }

      // Initialize Supabase
      supabase = window.supabase.createClient(url, key);
      
      // Reset stats
      stats = {
        total: 0,
        processed: 0,
        compressed: 0,
        skipped: 0,
        errors: 0,
        originalSize: 0,
        compressedSize: 0
      };
      shouldStop = false;

      // Update UI
      document.getElementById('startBtn').disabled = true;
      document.getElementById('stopBtn').disabled = false;
      document.getElementById('stats').style.display = 'grid';
      document.getElementById('progressBar').style.display = 'block';
      document.getElementById('logContainer').innerHTML = '';

      log('üöÄ Starting compression process...', 'info');

      try {
        // List all files in the bucket
        log(`üìÇ Fetching files from bucket: ${bucket}`, 'info');
        const { data: files, error } = await supabase.storage.from(bucket).list();

        if (error) {
          throw error;
        }

        if (!files || files.length === 0) {
          log('‚ö†Ô∏è No files found in bucket', 'warning');
          document.getElementById('startBtn').disabled = false;
          document.getElementById('stopBtn').disabled = true;
          return;
        }

        stats.total = files.length;
        log(`‚úÖ Found ${files.length} files`, 'success');
        updateStats();

        // Process each file
        for (const file of files) {
          if (shouldStop) {
            log('‚èπÔ∏è Compression stopped by user', 'warning');
            break;
          }

          try {
            log(`üì• Processing: ${file.name}`, 'info');

            // Download the file
            const { data: fileData, error: downloadError } = await supabase.storage
              .from(bucket)
              .download(file.name);

            if (downloadError) {
              throw downloadError;
            }

            const originalSize = fileData.size;
            stats.originalSize += originalSize;

            // Check if file is already under 50KB
            if (originalSize <= 50 * 1024) {
              log(`‚è≠Ô∏è Skipped ${file.name} (already ${(originalSize / 1024).toFixed(2)}KB)`, 'info');
              stats.skipped++;
              stats.compressedSize += originalSize;
              stats.processed++;
              updateStats();
              continue;
            }

            // Compress the image
            log(`üóúÔ∏è Compressing ${file.name} (${(originalSize / 1024).toFixed(2)}KB)...`, 'info');
            const compressedBlob = await compressImage(fileData, 600, 600, 0.6, 50);
            const compressedSize = compressedBlob.size;
            stats.compressedSize += compressedSize;

            // Create new filename with timestamp to ensure uniqueness
            const newFileName = file.name;

            // Upload compressed version (will replace the old one)
            const { error: uploadError } = await supabase.storage
              .from(bucket)
              .upload(newFileName, compressedBlob, {
                cacheControl: '3600',
                upsert: true
              });

            if (uploadError) {
              throw uploadError;
            }

            const savedKB = ((originalSize - compressedSize) / 1024).toFixed(2);
            const savedPercent = ((1 - compressedSize / originalSize) * 100).toFixed(1);
            log(`‚úÖ ${file.name}: ${(originalSize / 1024).toFixed(2)}KB ‚Üí ${(compressedSize / 1024).toFixed(2)}KB (saved ${savedKB}KB, ${savedPercent}%)`, 'success');
            
            stats.compressed++;
            stats.processed++;
            updateStats();

            // Small delay to prevent overwhelming the server
            await new Promise(resolve => setTimeout(resolve, 100));

          } catch (error) {
            log(`‚ùå Error processing ${file.name}: ${error.message}`, 'error');
            stats.errors++;
            stats.processed++;
            updateStats();
          }
        }

        log('üéâ Compression complete!', 'success');
        const totalSavedMB = ((stats.originalSize - stats.compressedSize) / (1024 * 1024)).toFixed(2);
        log(`üíæ Total space saved: ${totalSavedMB} MB`, 'success');

      } catch (error) {
        log(`‚ùå Fatal error: ${error.message}`, 'error');
      } finally {
        document.getElementById('startBtn').disabled = false;
        document.getElementById('stopBtn').disabled = true;
      }
    }

    function stopCompression() {
      shouldStop = true;
      log('‚èπÔ∏è Stopping compression...', 'warning');
      document.getElementById('stopBtn').disabled = true;
    }
  </script>
</body>
</html>

